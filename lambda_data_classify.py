from git import List

from src.service.lambda_global import get_all_data_and_save
from src.dependencies import get_lambda_sqlalchemy_repository, get_classifier_output_repository
from src.repositories.database import LambdaJobRepository, JobClassificationOutputRepository

from schemas.base_classifier import JobClassificationInput, JobClassificationOutput, JobClassifierAgentConfig, JobClassifierAgent
from src.agent.agent import AgentProcessor
import asyncio
import json
from dotenv import load_dotenv
import os
from markdownify import markdownify as md


load_dotenv()

dep = get_lambda_sqlalchemy_repository()
dep_classifier_output = get_classifier_output_repository()

async def main():
    #get all data from database
    repository: LambdaJobRepository = dep
    classifier_output_repository: JobClassificationOutputRepository = dep_classifier_output
    datas = repository.get_all()
    datas = datas[300:]

    print(f"Total jobs in database: {len(datas)}")
    #prepare data for classification
    classification_input = []
    for data in datas:
        dict_data = data.__dict__
        classification_input.append((
            JobClassificationInput(
            job_title=dict_data.get("title", ""),
            job_description=md(dict_data.get("description", "")),
            company_name=dict_data.get("company_name", ""),
            salary_max=dict_data.get("salary_max", None),
            salary_min=dict_data.get("salary_min", None),
            additional_info={
                "responsibilities": md(dict_data.get("responsibilities", "")),
                "skills": ", ".join(dict_data.get("skills", [])),
                "tags": ", ".join(dict_data.get("tags", [])),
                "recruiter_industry": dict_data.get("recruiter_industry", ""),
            }
        ), dict_data.get("id")
        ))

        # break

    #load agent config
    config = JobClassifierAgentConfig()
    agent = JobClassifierAgent(config=config)
    processor = AgentProcessor(agent=agent)
    
    # #classify data
    # for item in classification_input:
    #     print(f"Classifying job: {item.job_title} at {item.company_name}")
    #     output = await processor.process(input_data=item)
    #     print(f"Classification result: {output.__dict__}")
    #     print("----")

    # classify data batch that 50 by 50 and save result into database
    batch_size = 100
    for i in range(0, len(classification_input), batch_size):
        batch = classification_input[i:i+batch_size]
        # result : List[JobClassificationOutput] | None = await processor.process_batch([item[0] for item in batch])
        tasks = []
        for j in range(0, len(batch), batch_size//2):
            print(f"Processing sub-batch {j//(batch_size//2) + 1} of batch {i//batch_size + 1}")
            sub_batch = batch[j:j+(batch_size//2)]
            tasks.append(asyncio.create_task(processor.process_batch([item[0] for item in sub_batch])))
        results = await asyncio.gather(*tasks)
        result = []
        for res in results:
            if res is not None:
                result.extend(res)

        if result is None:
            print(f"Batch {i//batch_size + 1}: No classification result returned.")
            continue
            
        for output, (_, job_id) in zip(result, batch):
            # Create a new model instance (id will be auto-generated by database)
            output_dict = {
                "id": str(job_id),  # Use the same ID as the source job for traceability
                "title": output.title,
                "job_function": output.job_function,
                "job_industry": output.job_industry,
                "job_techpack_category": output.job_techpack_category,
                "job_level": output.job_level,
                "experience_level": output.experience_level,
                "education_level": output.education_level,
                "salary_min": output.salary_min,
                "salary_max": output.salary_max,
                "company_name": output.company_name,
                "requirement_reasoning": output.requirement_reasoning,
                "requirements": json.dumps([req.model_dump() for req in output.requirements], ensure_ascii=False),
                "benefits_reasoning": output.benefits_reasoning,
                "benefits": json.dumps([benefit.model_dump() for benefit in output.benefits], ensure_ascii=False),
                "confidence_scores": json.dumps(output.confidence_scores, ensure_ascii=False) if output.confidence_scores else None,
                "source_job": f"lambda"
            }

            classifier_output_repository.create(output_dict)

        print(f"Batch {i//batch_size + 1}: Classified and saved {len(batch)} jobs.")
if __name__ == "__main__":
    asyncio.run(main())